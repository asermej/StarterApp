---
description: "ACTIVE: DataManager rules - SQL data access implementation"
globs: apps/api/Platform.Domain/Managers/DataLayer/DataManagers/*DataManager.cs
alwaysApply: false
---

>>> CONTEXT LOADED: DataManager best practices are now active <<<

# DataManager Best Practices

**Template**: [DataManager.hbs](mdc:docs/templates/create/DataManager.hbs)

## Purpose
DataManagers handle **all SQL queries** for a domain entity using Dapper.

## Requirements

- **Internal sealed class**: Never expose publicly
- **Connection string in constructor**: Store for creating connections
- **Configure Dapper mapping**: Call `DapperConfiguration.ConfigureSnakeCaseMapping<T>()` in constructor
- **Parameterized queries ONLY**: Never concatenate SQL strings
- **Using statements**: Always dispose NpgsqlConnection
- **Soft delete**: Use `is_deleted = false` in WHERE clauses

## Pattern

```csharp
internal sealed class FeatureDataManager
{
    private readonly string _dbConnectionString;

    public FeatureDataManager(string dbConnectionString)
    {
        _dbConnectionString = dbConnectionString;
        DapperConfiguration.ConfigureSnakeCaseMapping<Feature>();
    }

    public async Task<Feature?> GetById(Guid id)
    {
        const string sql = @"
            SELECT id, name, created_at, updated_at, is_deleted
            FROM features
            WHERE id = @id AND is_deleted = false";
        using var connection = new NpgsqlConnection(_dbConnectionString);
        return await connection.QueryFirstOrDefaultAsync<Feature>(sql, new { id });
    }
}
```

## Do NOT

- Use string concatenation for SQL (SQL injection risk)
- Forget `is_deleted = false` in queries
- Add business logic (belongs in Manager)
- Handle exceptions (let them propagate)
