using System;
using System.Net.Http;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace Platform.Domain;

/// <summary>
/// Manages external API communication for {{integrationName}} integration
/// Handles HTTP requests, error handling, and mapping between domain and resource models
/// </summary>
internal sealed class {{integrationName}}Manager : IDisposable
{
    private readonly ServiceLocatorBase _serviceLocator;
    private HttpClient? _httpClient;
    private HttpClient HttpClient
    {
        get
        {
            if (_httpClient == null)
            {
                var config = _serviceLocator.CreateConfigurationProvider();
                var baseUrl = config.GetGatewayBaseUrl("{{integrationName}}");
                var timeout = config.GetGatewayTimeout("{{integrationName}}");
                _httpClient = _serviceLocator.CreateHttpClient(baseUrl, timeout);
                
                // Set authentication header if API key is required
                var apiKey = config.GetGatewayApiKey("{{integrationName}}");
                {{#if useApiKey}}
                _httpClient.DefaultRequestHeaders.Add("{{apiKeyHeaderName}}", apiKey);
                {{/if}}
            }
            return _httpClient;
        }
    }

    public {{integrationName}}Manager(ServiceLocatorBase serviceLocator)
    {
        _serviceLocator = serviceLocator ?? throw new ArgumentNullException(nameof(serviceLocator));
    }

    {{#each operations}}
    /// <summary>
    /// {{description}}
    /// </summary>
    {{#if parameters}}
    {{#each parameters}}
    /// <param name="{{camelCase name}}">{{description}}</param>
    {{/each}}
    {{/if}}
    /// <returns>{{returns}}</returns>
    public async Task<{{returnType}}> {{operationName}}({{#each parameters}}{{type}} {{camelCase name}}{{#unless @last}}, {{/unless}}{{/each}})
    {
        try
        {
            {{#if requestModel}}
            // Map domain model to resource model
            var requestResource = {{integrationName}}Mapper.To{{requestModel}}Resource({{#each parameters}}{{#if (eq name requestParameterName)}}{{camelCase name}}{{/if}}{{/each}});
            {{#if (ne httpMethod "GET")}}
            var jsonContent = JsonSerializer.Serialize(requestResource);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
            {{/if}}
            {{else if hasRequestBody}}
            // Create request resource from parameters
            var requestResource = new {{integrationName}}{{operationName}}Request
            {
                {{#each requestProperties}}
                {{name}} = {{camelCase ../requestPropertyMap name}},
                {{/each}}
            };
            {{#if (ne httpMethod "GET")}}
            var jsonContent = JsonSerializer.Serialize(requestResource);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
            {{/if}}
            {{/if}}
            
            // Make HTTP {{httpMethod}} request
            HttpResponseMessage response;
            {{#if (eq httpMethod "POST")}}
            {{#if requestModel}}
            response = await HttpClient.PostAsync("{{endpoint}}", content).ConfigureAwait(false);
            {{else if hasRequestBody}}
            response = await HttpClient.PostAsync("{{endpoint}}", content).ConfigureAwait(false);
            {{else}}
            response = await HttpClient.PostAsync("{{endpoint}}", null).ConfigureAwait(false);
            {{/if}}
            {{else if (eq httpMethod "GET")}}
            response = await HttpClient.GetAsync("{{endpoint}}").ConfigureAwait(false);
            {{else if (eq httpMethod "PUT")}}
            {{#if requestModel}}
            response = await HttpClient.PutAsync("{{endpoint}}", content).ConfigureAwait(false);
            {{else if hasRequestBody}}
            response = await HttpClient.PutAsync("{{endpoint}}", content).ConfigureAwait(false);
            {{else}}
            response = await HttpClient.PutAsync("{{endpoint}}", null).ConfigureAwait(false);
            {{/if}}
            {{else if (eq httpMethod "DELETE")}}
            response = await HttpClient.DeleteAsync("{{endpoint}}").ConfigureAwait(false);
            {{else if (eq httpMethod "PATCH")}}
            {{#if requestModel}}
            var patchRequest = new HttpRequestMessage(HttpMethod.Patch, "{{endpoint}}") { Content = content };
            response = await HttpClient.SendAsync(patchRequest).ConfigureAwait(false);
            {{else if hasRequestBody}}
            var patchRequest = new HttpRequestMessage(HttpMethod.Patch, "{{endpoint}}") { Content = content };
            response = await HttpClient.SendAsync(patchRequest).ConfigureAwait(false);
            {{else}}
            var patchRequest = new HttpRequestMessage(HttpMethod.Patch, "{{endpoint}}");
            response = await HttpClient.SendAsync(patchRequest).ConfigureAwait(false);
            {{/if}}
            {{else}}
            throw new NotImplementedException($"HTTP method '{{httpMethod}}' not implemented in template");
            {{/if}}
            
            // Handle response
            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                throw new {{integrationName}}ApiException($"{{integrationName}} API returned error: {response.StatusCode} - {errorContent}");
            }

            {{#if responseModel}}
            // Parse response and map back to domain model
            var responseContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
            var responseResource = JsonSerializer.Deserialize<{{integrationName}}{{responseModel}}Response>(responseContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            
            if (responseResource == null)
            {
                throw new {{integrationName}}ApiException("Failed to deserialize {{integrationName}} API response");
            }
            
            return {{integrationName}}Mapper.To{{responseModel}}Domain(responseResource);
            {{else if returnType}}
            {{#if (eq returnType "string")}}
            var responseContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
            return responseContent;
            {{else if (eq returnType "void")}}
            return;
            {{else}}
            var responseContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
            var responseResource = JsonSerializer.Deserialize<{{integrationName}}{{operationName}}Response>(responseContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            
            if (responseResource == null)
            {
                throw new {{integrationName}}ApiException("Failed to deserialize {{integrationName}} API response");
            }
            
            return responseResource;
            {{/if}}
            {{else}}
            return;
            {{/if}}
        }
        catch (HttpRequestException ex)
        {
            throw new {{integrationName}}ConnectionException($"Failed to connect to {{integrationName}} API: {ex.Message}", ex);
        }
        catch (TaskCanceledException ex)
        {
            throw new {{integrationName}}ConnectionException($"{{integrationName}} API request timed out: {ex.Message}", ex);
        }
        catch ({{integrationName}}ApiException)
        {
            throw; // Re-throw gateway-specific exceptions
        }
        catch ({{integrationName}}ConnectionException)
        {
            throw; // Re-throw gateway-specific exceptions
        }
        catch (Exception ex)
        {
            throw new {{integrationName}}ApiException($"Unexpected error calling {{integrationName}} API: {ex.Message}", ex);
        }
    }
    {{#unless @last}}

    {{/unless}}
    {{/each}}

    public void Dispose()
    {
        _httpClient?.Dispose();
    }
}

