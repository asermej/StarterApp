---
description:
globs:
alwaysApply: false
---
# üß™ Testing Standards

**PHILOSOPHY**: This project uses **custom test doubles** instead of external mocking frameworks to maintain clean dependencies and full control over test behavior.

## üö® CRITICAL TESTING BOUNDARY

**ONLY TEST THE DomainFacade**: All acceptance tests MUST ONLY interact with the `DomainFacade` interface. This keeps the underlying implementation black-boxed and easily refactorable.

### ‚úÖ **DO**: Test Through DomainFacade Only
```csharp
[TestClass]
public class CustomerFeatureTests
{
    private DomainFacade _domainFacade;

    [TestMethod]
    public async Task CreateCustomer_ValidData_ReturnsValidId()
    {
        // ‚úÖ CORRECT: Test through DomainFacade only
        var customer = new Customer { FirstName = "TestJohn", Email = "john@example.com" };
        var result = await _domainFacade.CreateCustomer(customer);
        
        Assert.IsTrue(result.IsSuccess);
        Assert.AreNotEqual(Guid.Empty, result.Value);
    }
}
```

### ‚ùå **DON'T**: Test Individual Classes
```csharp
[TestClass]
public class CustomerManagerTests // ‚ùå WRONG: Don't test managers directly
{
    [TestMethod]
    public async Task CustomerManager_CreateCustomer_CallsDataFacade()
    {
        // ‚ùå WRONG: Testing internal implementation
        var manager = new CustomerManager(serviceLocator);
        var result = await manager.CreateCustomer(customer);
        // This breaks encapsulation and makes refactoring difficult
    }
}

[TestClass] 
public class CustomerDataManagerTests // ‚ùå WRONG: Don't test data managers
{
    [TestMethod]
    public async Task CustomerDataManager_Insert_ExecutesCorrectSQL()
    {
        // ‚ùå WRONG: Testing internal data access implementation
        var dataManager = new CustomerDataManager(connectionString);
        // This couples tests to implementation details
    }
}
```

## Core Testing Principles

### 1. **No External Mocking Frameworks**
- ‚ùå **DON'T**: Use Moq, NSubstitute, or any external mocking library
- ‚úÖ **DO**: Create custom test doubles, stubs, and fakes
- **Reason**: Maintains clean architecture, no external dependencies, full control

### 2. **InternalsVisibleTo Pattern**
- **Assembly Attribute**: `[assembly: InternalsVisibleTo("Platform.AcceptanceTests")]` in `Platform.DomainLayer`
- **Purpose**: Allows tests to access internal constructors and methods for test double creation
- **Scope**: Only for Platform.AcceptanceTests, not for production code

### 3. **Test Double Types**

#### **Stubs**: Provide canned answers to calls
```csharp
internal class StubEmailService : IEmailService
{
    public bool SendEmailCalled { get; private set; }
    public string LastEmailSent { get; private set; }
    
    public Task<bool> SendEmailAsync(string to, string subject, string body)
    {
        SendEmailCalled = true;
        LastEmailSent = $"{to}: {subject}";
        return Task.FromResult(true);
    }
}
```

#### **Fakes**: Working implementations with shortcuts
```csharp
internal class FakeCustomerRepository : ICustomerRepository
{
    private readonly List<Customer> _customers = new();
    
    public Task<Customer> GetByIdAsync(Guid id)
    {
        return Task.FromResult(_customers.FirstOrDefault(c => c.Id == id));
    }
    
    public Task<Guid> CreateAsync(Customer customer)
    {
        customer.Id = Guid.NewGuid();
        _customers.Add(customer);
        return Task.FromResult(customer.Id);
    }
}
```

## Database Test Cleanup Strategy

### **Enhanced Test Cleanup Pattern**
- **Database-Level Cleanup**: Use direct SQL for efficient test data removal
- **Pattern-Based Identification**: Identify test data by consistent patterns
- **Complete Isolation**: Clean up before AND after each test
- **Robust Error Handling**: Cleanup failures don't break tests

### **Required Test Structure**
```csharp
[TestClass]
public class CustomerManagerTests
{
    private DomainFacade _domainFacade;

    [TestInitialize]
    public void TestInitialize()
    {
        // Clean up ALL test data before each test to ensure complete isolation
        CleanupAllTestData();
        _domainFacade = new DomainFacade(new ServiceLocatorForAcceptanceTesting());
    }

    [TestCleanup]
    public void TestCleanup()
    {
        try
        {
            // Clean up any remaining test data after the test
            CleanupAllTestData();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Error during test cleanup: {ex.Message}");
        }
        finally
        {
            _domainFacade?.Dispose();
        }
    }

    private void CleanupAllTestData()
    {
        // Database-level cleanup using pattern-based identification
        var deleteSql = @"
            DELETE FROM customers 
            WHERE email LIKE '%@example.com' 
               OR email LIKE '%@test.com'
               OR first_name IN ('John', 'Jane', 'Bob', 'Alice', 'Test')
               OR first_name LIKE 'Test%'
               OR first_name LIKE 'Search%'";
        
        // Execute cleanup SQL
        using var connection = new NpgsqlConnection(_connectionString);
        connection.Execute(deleteSql);
    }
}
```

## Test Data Patterns

### **Consistent Test Data Identification**
- **Email Domains**: `@example.com`, `@test.com`, `@unittest.com`
- **Name Prefixes**: `Test`, `Search`, `Pagination`, `Validation`
- **Common Test Names**: `John`, `Jane`, `Bob`, `Alice`
- **Status Values**: `TestStatus`, `ValidationTest`

### **Test Data Examples**
```csharp
// ‚úÖ Good test data - easily identifiable
var testCustomer = new Customer
{
    FirstName = "TestJohn",
    LastName = "TestDoe", 
    Email = "john.doe@example.com"
};

// ‚úÖ Good test data - pattern-based
var searchCustomer = new Customer
{
    FirstName = "SearchCustomer",
    LastName = "ForTesting",
    Email = "search.test@unittest.com"
};
```

## Test Assertion Best Practices

### **Always Include Error Messages**
```csharp
// ‚úÖ DO: Include descriptive error messages
Assert.IsNotNull(result, $"Expected customer to be created, but got null. Error: {result?.Error?.Message}");
Assert.AreEqual(expectedEmail, result.Email, $"Expected email {expectedEmail}, but got {result.Email}");

// ‚ùå DON'T: Silent assertions
Assert.IsNotNull(result);
Assert.AreEqual(expectedEmail, result.Email);
```

### **Log Important Information**
```csharp
[TestMethod]
public async Task CreateCustomer_ValidData_ReturnsValidId()
{
    // Arrange
    var customer = new Customer { FirstName = "TestJohn", Email = "john@example.com" };
    
    // Act
    var result = await _domainFacade.CreateCustomer(customer);
    
    // Assert
    Console.WriteLine($"Customer created with ID: {result.Value}");
    Assert.IsTrue(result.IsSuccess, $"Expected success, but got error: {result.Error?.Message}");
    Assert.AreNotEqual(Guid.Empty, result.Value, "Expected a valid Guid for customer ID");
}
```

## Test Organization

### **File Structure**
```
Platform.AcceptanceTests/
‚îú‚îÄ‚îÄ DomainLayer/
‚îÇ   ‚îú‚îÄ‚îÄ CustomerFeatureTests.cs      // ‚úÖ Feature-based test files
‚îÇ   ‚îú‚îÄ‚îÄ OrderFeatureTests.cs         // ‚úÖ Test complete features
‚îÇ   ‚îî‚îÄ‚îÄ DomainFacadeGeneralTests.cs  // ‚úÖ General DomainFacade tests
‚îú‚îÄ‚îÄ TestDoubles/
‚îÇ   ‚îú‚îÄ‚îÄ StubEmailService.cs          // ‚úÖ Custom test doubles only
‚îÇ   ‚îú‚îÄ‚îÄ FakePaymentGateway.cs        // ‚úÖ For external dependencies
‚îÇ   ‚îî‚îÄ‚îÄ TestDataBuilder.cs           // ‚úÖ Helper for test data creation
‚îî‚îÄ‚îÄ ServiceLocator/
    ‚îî‚îÄ‚îÄ ServiceLocatorForAcceptanceTesting.cs
```

### **Test Naming Convention**
- **Class**: `{FeatureName}FeatureTests.cs` (NOT `{ClassName}Tests.cs`)
- **Method**: `{FeatureName}_{Scenario}_{ExpectedResult}`
- **Examples**: 
  - `CreateCustomer_ValidData_ReturnsValidId`
  - `CreateCustomer_DuplicateEmail_ThrowsBusinessException`
  - `SearchCustomers_WithPagination_ReturnsCorrectPage`

### **What NOT to Create**
- ‚ùå `CustomerManagerTests.cs` - Don't test managers directly
- ‚ùå `CustomerDataManagerTests.cs` - Don't test data managers directly  
- ‚ùå `CustomerValidatorTests.cs` - Don't test validators directly
- ‚ùå `DataFacadeTests.cs` - Don't test data facade directly

### **Rationale for DomainFacade-Only Testing**
1. **Black Box Testing**: Internal implementation can be refactored without breaking tests
2. **Behavioral Focus**: Tests verify business behavior, not implementation details
3. **Maintainability**: Fewer tests to maintain, focused on what matters to users
4. **Refactoring Safety**: Can restructure internal classes without test changes
5. **Integration Confidence**: Tests verify the complete feature works end-to-end

## Performance Considerations

### **Database Cleanup Performance**
- **Single SQL Operation**: Use one DELETE statement with multiple conditions
- **Avoid Multiple API Calls**: Don't delete through domain layer in cleanup
- **Pattern-Based**: Use LIKE and IN clauses for efficient pattern matching

### **Test Isolation**
- **Complete Data Isolation**: Each test starts with clean slate
- **No Test Dependencies**: Tests can run in any order
- **Parallel Execution**: Tests don't interfere with each other

## Anti-Patterns to Avoid

### **‚ùå External Mocking Frameworks**
```csharp
// DON'T do this
var mockEmailService = new Mock<IEmailService>();
mockEmailService.Setup(x => x.SendEmailAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))
           .ReturnsAsync(true);
```

### **‚ùå Production Dependencies in Tests**
```csharp
// DON'T do this - no external services in tests
var realEmailService = new SmtpEmailService();
var realPaymentGateway = new StripePaymentGateway();
```

### **‚ùå Testing Internal Classes**
```csharp
// DON'T do this - testing internal implementation
[TestClass]
public class CustomerManagerTests
{
    [TestMethod]
    public async Task CreateCustomer_CallsDataFacade()
    {
        var manager = new CustomerManager(serviceLocator);
        // This breaks the black box principle
    }
}

// DON'T do this - testing data layer directly
[TestClass] 
public class CustomerDataManagerTests
{
    [TestMethod]
    public async Task Insert_ExecutesSQL()
    {
        var dataManager = new CustomerDataManager(connectionString);
        // This couples tests to implementation details
    }
}
```

### **‚ùå Incomplete Cleanup**
```csharp
// DON'T do this - incomplete cleanup
[TestCleanup]
public void TestCleanup()
{
    // Only cleaning up some data
    _domainFacade.DeleteCustomer(customerId);
    // Missing other test data cleanup
}
```

### **‚ùå Silent Test Failures**
```csharp
// DON'T do this - no error context
Assert.IsTrue(result.IsSuccess);
Assert.AreEqual(expected, actual);
```

## Template Usage

- **Test Template**: Use `../templates/create/Test.hbs` for all new test files
- **Test Double Templates**: Create standardized templates for common test double patterns
- **Cleanup Templates**: Standardize cleanup patterns across all test classes

---

**Remember**: Tests are first-class citizens in this architecture. They should be as well-crafted and maintainable as production code.
