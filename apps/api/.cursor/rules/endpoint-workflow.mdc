---
description: This workflow guides the development of a new API endpoint interactively. It prompts for information at each stage, generates code using `.hbs` templates, and waits for confirmation before proceeding.
globs: 
alwaysApply: false
---
---
description: Interactive 8-phase workflow for creating new API endpoints with template verification
keywords: ["endpoint", "workflow", "interactive", "templates", "feature creation", "API development"]
applies_to: ["Platform.Api", "Platform.Domain", "Platform.AcceptanceTests"]
alwaysApply: false
priority: 900
triggers: ["new feature", "create feature", "build feature", "new endpoint", "create API", "add endpoint", "CRUD", "REST API"]
related_files: ["principles.mdc", "../Platform.Database/.cursor/rules/database-workflow.mdc", "../Platform.AcceptanceTests/.cursor/rules/testing-standards.mdc"]
template_directory: "../templates/create/"
---

# ðŸš€ Interactive API Endpoint Development Workflow

**MANDATORY PROCESS**: This workflow guides the development of a new API endpoint interactively. It prompts for information at each stage, generates code using `.hbs` templates, and waits for confirmation before proceeding.

**ðŸš¨ CRITICAL**: This is NOT optional guidance - it is the REQUIRED process for all new API features.

**Reference**: For all architectural decisions, refer to the [Backend Architecture Principles](mdc:principles.mdc).

---

## Phase 1: Intelligent Feature Scoping

**Goal**: Define the high-level requirements for the new feature through an interactive, step-by-step process that infers details and asks for confirmation.

**Action**: Guide the user through a series of prompts, inferring information where possible and allowing for edits.

**(Prompt 1: Infer Feature Name)**
"To begin, I will infer the **Feature Name** from your request. For example, if you say 'I need to manage user profiles,' I will infer `UserProfile`.

It looks like you want to create a feature for `{{featureName}}`. Is that correct?"
**(Wait for user confirmation)**

**(Prompt 2: Properties)**
"Great. Now, what are the **Properties** of your entity? Please provide them as a comma-separated list with their C# types. (e.g., `Id:Guid, ProductName:string, Sku:string, CreatedAt:DateTime`)"
**(Wait for user response)**

**(Prompt 3: Propose & Refine Constraints)**
"Understood. I've analyzed your properties and have proposed some database constraints below. Please review and edit them as needed.

**Suggested Constraints:**
```
- Id:Guid[primary_key]
- ProductName:string[max_length:255, not_null]
- Sku:string[max_length:100, not_null, unique]
- CreatedAt:DateTime[not_null]
```

**Common Constraints You Can Add:**
*   `primary_key`: Marks the field as the primary key.
*   `not_null`: Ensures the field cannot be empty.
*   `unique`: Ensures all values in the column are unique.
*   `max_length:<number>`: Sets the maximum length for a string.
*   `default:<value>`: Sets a default value (e.g., `default:true`).

You can copy the block above and edit it directly in your response if you need any changes. Otherwise, just say 'looks good'."
**(Wait for user response)**

**(Prompt 4: Operations)**
"Got it. Now, which **Operations** will be needed? You can choose any combination of `Create`, `GetById`, `Search`, `Update`, `Delete`. (e.g., 'Create, GetById, Search')"
**(Wait for user response)**

**(Prompt 5: Infer Database Table Name Using Postgres Naming Conventions)**
"Based on the feature name, I suggest the database table name `{{tableName}}`. Is this correct?"
**(Wait for user confirmation)**

**(Prompt 6: Searchable Fields)**
"And finally, which of the properties will be **Searchable Fields**? (e.g., 'Username, Email')"
**(Wait for user response)**

**(Action: Summarize and Confirm)**
"Thank you. I have all the details. Here is the plan based on your input:
*   **Feature**: `{{featureName}}`
*   **Operations**: `{{operations}}`
*   **Table**: `{{tableName}}`
*   **Properties**: `{{properties}}`
*   **Searchable Fields**: `{{searchableFields}}`

Shall I proceed to Phase 2: Database Layer?"

---

## Phase 2: Database Layer

**Goal**: Create and register the database migration script, strictly following the specified naming convention and interactive flow.

**Reference**: For detailed database rules, refer to [liquibase-best-practices.mdc](mdc:.cursor/rules/database/liquibase-best-practices.mdc).

**Action**: Generate the changeset file with a timestamp-based name, get user confirmation, create the file, and then register it.

**(Prompt to User)**
"Next, I will create and register the **Liquibase Changeset**.

*   **Step 1: Generate Filename**: I will first generate a filename using the required format: `<timestamp>-{{featureName}}.xml`. For example: `$(date +%Y%m%d%H%M%S)-{{featureName}}.xml`.
*   **Step 2: Propose Changeset**: I will then propose creating the file with the generated name at `Platform.Database/changelog/changes/`.
*   **Step 3: Register Changeset**: After the file is created, I will update `Platform.Database/changelog/db.changelog-master.xml` to include it.

**IMPORTANT**:
*   The filename MUST be `<timestamp>-{{featureName}}.xml`.
*   The `<changeSet>` `id` attribute inside the XML MUST also be unique, using the format `<timestamp>-<description>` (e.g., `id="20250621224920-create-users-table"`).
*   DO NOT use sequential numbering for filenames (e.g., `002-feature.xml`).
*   I will wait for your explicit confirmation ("Ready to proceed?") before creating any files.

Ready to proceed?"

**(Wait for user confirmation, then execute the steps in order)**

---

## Phase 3: Domain Layer (File by File)

**Goal**: Implement the core business logic, one class at a time, with strict verification against the source templates.

**Action**: Prompt the user before each sub-task. For each file, perform a "Generate, Verify, & Notify" process.

**ðŸš¨ CRITICAL NOTE ON JOIN TABLES**: If you are creating a junction/join table entity (e.g., `PersonaTopic`, `TopicTag`), do NOT expose it directly in the `DomainFacade`. Instead:
1. Create the join table manager internally
2. Add relationship management methods to the **primary entity's manager** (e.g., `PersonaManager` or `TopicManager`)
3. Expose these methods through the primary entity's `DomainFacade` extension
4. Keep the join table manager internal and never reference it in `DomainFacade.cs`

See [Join Table Encapsulation](mdc:principles.mdc#join-table-encapsulation) for detailed guidance.

**Verification Process for Domain Layer Files**:
1.  **Generate**: Create the file by populating the relevant `.hbs` template with the feature details.
2.  **Verify**: Immediately after creation, re-populate the same template in memory to create an "expected" version of the file content. I will then read the actual generated file from disk and perform a full comparison against this "expected" version.
3.  **Notify**: I will report to you whether the generated file **perfectly matches** the template's design or if there are **discrepancies**. If they do not match, I will highlight the differences. This verification covers all aspects of the file, including the namespace, class structure, properties, and methods.

### 3.1 Domain Model
**(Prompt to User)**
"Now for the **Domain Model**. I will generate and then verify the code based on the following details:
*   **File**: `{{featureName}}.cs`
*   **Location**: `Platform.Domain/Managers/Models/`
*   **Purpose**: Defines the core C# entity for `{{featureName}}`.
*   **Template**: `.cursor/templates/api/create/DomainModel.hbs`

**Action**: After generating the file, I will verify its entire content against the template's expected output and report the result to you before proceeding.

Proceed?"

### 3.2 Exceptions
**(Prompt to User)**
"Next, I will create the **Custom Exceptions**. I will generate the code based on the following details:
*   **Files**: 
    *   `{{featureName}}ValidationException.cs`
    *   `{{featureName}}NotFoundException.cs`
    *   `{{featureName}}DuplicateException.cs`
*   **Location**: `Platform.Domain/Managers/Exceptions/`
*   **Purpose**: Defines the custom exceptions for the `{{featureName}}` feature.
*   **Templates**: 
    *   `.cursor/templates/api/create/ValidationException.hbs`
    *   `.cursor/templates/api/create/NotFoundException.hbs`
    *   `.cursor/templates/api/create/DuplicateException.hbs`

**Action**: After generating the files, I will verify their entire content against the templates' expected output and report the results to you before proceeding.

Proceed?"

### 3.3 Data Manager
**(Prompt to User)**
"Next, the **Data Manager**. I will generate and verify the code based on the following details:
*   **File**: `{{featureName}}DataManager.cs`
*   **Location**: `Platform.Domain/Managers/DataLayer/DataManagers/`
*   **Purpose**: Handles all SQL queries for the `{{featureName}}` entity.
*   **Template**: `.cursor/templates/api/create/DataManager.hbs`

**Action**: After generating the file, I will verify its entire content against the template's expected output and report the result to you before proceeding.

Proceed?"

### 3.4 Data Facades
**(Prompt to User)**
"Now, I'll create and verify the **Data Facade Extensions**. I will generate the code based on the following details:
*   **Files**: `DataFacade.{{featureName}}.cs`.
*   **Purpose**: These `partial` classes will expose the new data and domain logic.
*   **Templates**: `.cursor/templates/api/create/DataFacade.hbs`

**Action**: After generating the files, I will verify their entire content against the templates' expected output and report the results to you before proceeding.

Proceed?"

### 3.5 Validator
**(Prompt to User)**
"Now for the **Validator**. I will generate and then verify the code based on the following details:
*   **File**: `{{featureName}}Validator.cs`
*   **Location**: `Platform.Domain/Managers/Validators/`
*   **Purpose**: Defines the validation logic for the `{{featureName}}` entity.
*   **Template**: `.cursor/templates/api/create/Validator.hbs`

**Action**: After generating the file, I will verify its entire content against the template's expected output and report the result to you before proceeding.

Proceed?"

### 3.6 Domain Manager
**(Prompt to User)**
"Next up is the **Domain Manager**. I will generate and verify the code based on the following details:
*   **File**: `{{featureName}}Manager.cs`
*   **Location**: `Platform.Domain/Managers/`
*   **Purpose**: Orchestrates validation and calls the DataFacade.
*   **Template**: `.cursor/templates/api/create/Manager.hbs`

**Action**: After generating the file, I will verify its entire content against the template's expected output and report the result to you before proceeding.

Proceed?"

### 3.7 Domain Facade
**(Prompt to User)**
"Next, I will update the **Domain Facade**. I will add the manager initialization and disposal logic to `DomainFacade.cs`.
*   **File**: `DomainFacade.cs`
*   **Location**: `Platform.Domain/`
*   **Purpose**: To register the new manager with the main `DomainFacade`.
*   **Action**: I will directly edit the file to insert the new manager's private field, property, and `Dispose()` call.

Proceed?"

### 3.8 Domain Facade Extension
**(Prompt to User)**
"Now, I'll create and verify the **Domain Facade Extension**. I will generate the code based on the following details:
*   **Files**: `DomainFacade.{{featureName}}.cs`.
*   **Purpose**: These `partial` classes will expose the new data and domain logic.
*   **Templates**: `.cursor/templates/api/create/DomainFacade.Base.hbs`

Proceed?"

---

## Phase 4: Acceptance Tests

**Goal**: Create and verify acceptance tests for the new domain logic, ensuring it works correctly before building the API.

**ðŸš¨ CRITICAL TESTING BOUNDARY**: Tests MUST ONLY interact with the `DomainFacade` interface. DO NOT create tests for individual managers, data managers, or validators. This keeps the implementation black-boxed and easily refactorable.

**Action**: Generate the test file, run the tests, and confirm they pass.

### 4.1 Generate Test File
**(Prompt to User)**
"Now for the **Acceptance Test**. I will generate the test code based on the following details:
*   **File**: `DomainFacadeTests.{{featureName}}.cs`
*   **Location**: `Platform.AcceptanceTests/Domain/`
*   **Purpose**: To test the entire {{featureName}} feature through the `DomainFacade` ONLY against a real test database, ensuring all operations work as expected.
*   **Template**: `.cursor/templates/api/create/DomainFacadeTests.Base.hbs`
*   **IMPORTANT**: The test will ONLY call `DomainFacade` methods - no direct testing of managers, data managers, or validators.

Ready to generate the test file?"
**(Wait for user confirmation)**

### 4.2 Verify Tests
**(Prompt to User)**
"After generating the test file, I will run the acceptance tests to verify the `Domain` logic. I will report the results to you before proceeding.

Proceed with running the tests?"
**(Wait for user confirmation, then execute `dotnet test` and report results)**

---

## Phase 5: API Layer (File by File)

**Goal**: Expose the verified domain logic via a public HTTP endpoint, strictly using the provided templates.

**Action**: For each file, generate the code by strictly populating the specified `.hbs` template. **Do not** use existing files as a reference or example.

### 5.1 Resource Model
**(Prompt to User)**
"Moving to the API Layer. First, the **Resource Model**. I will generate the code based on the following details:
*   **File**: `{{featureName}}Resource.cs`
*   **Location**: `Platform.Api/ResourcesModels/`
*   **Purpose**: The DTO that defines the JSON shape for API requests/responses.
*   **Template**: `.cursor/templates/api/create/ResourceModel.hbs`

Proceed?"

### 5.2 Mapper
**(Prompt to User)**
"Next, the **Mapper**. I will generate the code based on the following details:
*   **File**: `{{featureName}}Mapper.cs`
*   **Location**: `Platform.Api/Mappers/`
*   **Purpose**: Maps data between the Domain Model and the Resource Model.
*   **Template**: `.cursor/templates/api/create/Mapper.hbs`

Proceed?"

### 5.3 Controller
**(Prompt to User)**
"Finally, the **Controller**. I will generate the code based on the following details:
*   **File**: `{{featureName}}Controller.cs`
*   **Location**: `Platform.Api/Controllers/`
*   **Purpose**: The public HTTP entry point for the `{{featureName}}` feature.
*   **Template**: `.cursor/templates/api/create/Controller.hbs`

Proceed?"

---
## Workflow Complete
All files for the `{{featureName}}` feature have been created.
